#!/bin/bash
UA="Spinach"
VE="0.4.25"

unset v Op Rep Red Green Yellow Blue Nc

v=0 #set to 1 for verbose messages (msg v cow), of which there currently are none...
pkgargs=()
Threads=10
SudovSleep=5
Proto="http"
Host="aur.archlinux.org"
Pkg="packages/%s/%s.tar.gz"
Rpc="rpc.php?type=%s&arg=%s"

#
# Functions for main functionality
#

spin_search() { #$1 = v or q, verbose or quiet
	local query="$2"

	if [[ $1 == q ]]; then
		(($Rep)) && pacman -Ssq "$query"
		spin_curl r search "$query" | \
			grep -Eo '"Name":"[^"]*"' | sed -r 's/"Name":"([^"]*)"/\1/g'
	else
		(($Rep)) && pacman -Ss "$query" | sed -r 's/^([^/\s]+\/[^ ]+) [^\n]+$/\1/g' | \
			sed -rn '1h;1!H;${;g;s/\n\s+/: /g;p;}' | display_color
		spin_curl r search "$query" | sed -r '
			s/.*(No results found).*/\1\n/g
			s/^\{"type":"error".*/No results found/g
			s/"Version":"[^"]+"//g
			s/\\"/\&QUOT;/g
			s/.*\[([^"]*)\]}}/\1/g
			s/\{[^}]*"Name":"([^"]*)",[^}]*,"Description":"([^"]*)"[^}]*\}/\1: \2\n/g
			s/^,//mg
			s/\\\//\//mg
			s/\\\\/\\/mg
			s/\&QUOT;/"/mg
			s/^]}//mg' | sort | display_color
	fi
}

spin_info() {
	local query info getinfo
	query="$@"

	if (($Rep)); then
		info="$(pacman -Si "$query" 2>/dev/null)"
		gotinfo=$?

		[[ $info ]] && display_color <<< "$info"
	fi

	if (( ! $Rep || $gotinfo )); then
		spin_curl r info "$query" | sed -r '
			s/.*No result found.*/Error:Package not found/g
			s/\\"/\&QUOT;/g
			s/.*results":\{(.*)\}\}/\1/g
			s/\",\"/\"\n\"/g
			s/\\\//\//mg
			s/"//mg
			s/^([^:]*):/\1: /mg
			s/\\\\/\\/mg
			s/\&QUOT;/"/mg
			s/^URLPath: /URLPath: https:\/\/aur.archlinux.org/mg' | display_color
		echo
	fi
}

spin_install() {
	local i pkg
	
	blank_editor	|| return 1
	create_tmp	|| return 1
	
	cd "$Tmp_build"

	Fromrepo=0
	Downloaded=()
	InstallPacman=()
	InstallExplicit=()
	InstallDepends=()
	CompiledExplicit=()
	trap "clean_downloaded; kill \$Sudov &>/dev/null; exit 1" 0
	trap "clean_downloaded; kill \$Sudov &>/dev/null; echo; exit 1" 2 15

	#download
	for pkg; do
		if (($Rep)) && { pacman -Si "$pkg" &>/dev/null || \
			[[ $(pacman -Sgq "$pkg" 2>/dev/null | wc -l) != 0 ]]; }; then
			run_pacman -S $1
			((Fromrepo++))
		else
			spin_download_all e "$pkg"
		fi
	done

	#spin_download_all set it
	unset IFS

	#don't run anything else if there is nothing to do
	(( Fromrepo > 0 && ${#Downloaded[@]} == 0 )) && return 0

	#preview
	for pkg in "${InstallExplicit[@]}" "${InstallDepends[@]}"; do
		cd "$pkg"
		preview "$pkg"
		cd "$Tmp_build"
	done
	
	#install pacman depends
	(( ${#InstallPacman[@]} > 0 )) && \
		run_pacman --needed --asdeps -S "${InstallPacman[@]}"

	#keep password cached while installing
	if type sudo &>/dev/null; then
		msg c "Running" "sudo -v"
		sudo -v || { msg e "Could not authenticate."; exit 1; }
		sudov &
		Sudov=$!
	fi

	#build Install{Depends,Explicit}
	build_all

	kill $Sudov &>/dev/null
	clean_downloaded
	trap - 0 2 15
}

spin_update() {
	local i pkg toUpdate
	
	blank_editor	|| return 1
	create_tmp	|| return 1
	
	cd "$Tmp_build"

	#Outputs array to $Updates
	spin_find_updates

	toUpdate=()
	Fromrepo=0
	Downloaded=()
	InstallPacman=()
	InstallDepends=()
	InstallExplicit=()
	CompiledExplicit=()
	[[ -e $Tmp/update.lock ]] && msg e "update lock exists" && return 1
	touch "$Tmp/update.lock"

	trap "clean_downloaded; rm \"$Tmp/update.lock\" &>/dev/null; kill \$Sudov &>/dev/null; exit 1" 0
	trap "clean_downloaded; rm \"$Tmp/update.lock\" &>/dev/null; kill \$Sudov &>/dev/null; echo; exit 1" 2 15

	#find out what to update
	for pkg in "${Updates[@]}"; do
		yes_no "Update $pkg?"
		[[ $Response == y ]] && toUpdate+=("$pkg")
	done
	
	#don't ask for password to do nothing
	(( ${#toUpdate[@]} == 0 )) && exit 0

	#only download what user wanted to update
	for pkg in "${toUpdate[@]}"; do
		spin_download_all e "$pkg"
	done
	
	#spin_download_all set it
	unset IFS

	#preview
	for pkg in "${InstallExplicit[@]}" "${InstallDepends[@]}"; do
		cd "$pkg"
		preview "$pkg"
		cd "$Tmp_build"
	done
	
	#install pacman depends
	(( ${#InstallPacman[@]} > 0 )) && \
		run_pacman --needed --asdeps -S "${InstallPacman[@]}"

	#keep password cached while installing
	if type sudo &>/dev/null; then
		msg c "Running" "sudo -v"
		sudo -v || { msg e "Could not authenticate."; exit 1; }
		sudov &
		Sudov=$!
	fi

	#build Install{Depends,Explicit}
	build_all

	rm "$Tmp/update.lock"
	kill $Sudov &>/dev/null
	clean_downloaded
	trap - 0 2 15
}

spin_find_updates() { #prints to stdout, outputs array to $Updates
	local pkg packages ignore kill_list number urls inaur inlocal name up in threadnum

	create_tmp || return 1

	Updates=()
	packages="$(pacman -Qmq 2>/dev/null)"

	#remove ignored
	ignore="$(grep ^IgnorePkg /etc/pacman.conf | sed -e "s/.*=\ //g")"
	for pkg in $ignore; do
		packages="$(grep -v "$pkg" <<< "$packages")"
	done

	#get versions from aur with multiple threads
	aur_versions="$Tmp/findupdates_$$"
	kill_list=()
	threads=()
	trap "kill \"\${kill_list[@]}\" &>/dev/null; rm \"${aur_versions}\"_* &>/dev/null; exit 1" 0 2 15
	number=0
	
	#split urls for diff threads
	for pkg in $packages; do
		threads[$number]+="$(printf "%s://%s/$Rpc" "$Proto" "$Host" info "$pkg") "
		(( number == Threads )) && number=0 || ((number++))
	done

	#create threads
	threadnum=0
	for urls in "${threads[@]}"; do
		curl -sfA "$UA" -m 6 --compressed --retry-delay 1 --retry 4 $urls >> "$aur_versions"_$threadnum &
		kill_list+=("$!")
		((threadnum++))
	done

	#wait for threads
	while (( $(jobs|wc -l) > 0 )); do
		sleep 0.05
		jobs &>/dev/null
	done

	inaur="$(cat "$aur_versions"_* | sed -re '
		s/\{[^}]*"results":"No results? found"\}//g
		s/\{+[^}]*Name":"([^"]*)"[^}]*Version":"([^"]*)[^}]*\}+/\1\t\2\n/g' | sort)"
	trap - 0 2 15
	rm "$aur_versions"_*

	#get installed versions
	inlocal="$(pacman -Qi $packages | grep -E '^(Name|Version)' | tr '\n' ' ' | \
		sed -r 's/(Name|Version)\s+: /\n/g' | tail -n +2 | sed 's/ $//g')"

	#find differences
	IFS=$'\n'
	for pkg in $inaur; do
		name="$(cut -f1 <<< "$pkg")"
		#up-to-date version
		up="$(cut -f2 <<< "$pkg")"
		#installed version
		in="$(grep -A 1 "^$name$" <<< "$inlocal" | tail -n 1)"

		if [[ $up != $in && -n $up && -n $in && -z $(grep "No result found" <<< "$up") ]] \
			&& [[ $(vercmp "$in" "$up") == -1 ]]; then
			Updates+=("$name")
			printf "${Red}%s${Nc} (${Blue}%s${Nc} => ${Green}%s${Nc})\n" "$name" "$in" "$up"
		fi
	done
}

spin_download_updates() {
	local pkg inst files

	#Outputs array to $Updates
	spin_find_updates

	#download
	for pkg in "${Updates[@]}"; do
		spin_download_all e "$pkg" print
	done
}

spin_download_all() { #$1 = e or d, explicit or depend; $2 = pkg
	local typ pkg dep depends provides completed
	typ="$1"
	pkg="$2"

	if [[ ! -e $pkg ]]; then
		if spin_download "$pkg"; then
			Downloaded+=("$pkg")

			case "$typ" in
				d) InstallDepends+=("$pkg");;
				e) InstallExplicit+=("$pkg");;
				*) return 1;;
			esac

			msg c "Saved" "$pkg"

			if [[ -e $pkg/PKGBUILD ]]; then
				while true; do
					completed=1
					depends="$(tr '\n' ' ' < "$pkg/PKGBUILD" | \
						grep -Eos " (make)?depends=\([^)]*\)" | sed -r "
						s/.*\((.*)\).*/\1/mg
						s/(['\"])([^><=']*)[><=]+[^'\"]*\1/\2/mg
						s/['\"]//mg" | tr '\n' ' ' | tr '\t' ' ' | sed -r "s/\\\$[^ ]+ //mg")"
					depends="$(pacman -T $depends | tr '\n' ' ')"

					provides="$(pacman -Si $(pacman -Ssq "($(tr ' ' '|' <<< "$depends"|tr '\n' '|'))"||echo -h) | \
						grep -E "^(Name|Provides)" | sed -r '
						s/^[^:]*: //mg
						s/=[^ ]*//mg' | tr ' ' '\n')"

					IFS=$' '
					for dep in $depends; do
						unset IFS
						if ! grep -q "^$dep$" <<< "$provides"; then
							if [[ ! -e $dep/ ]] && ! spin_download_all d "$dep"; then
								completed=0
								yes_no "Modify PKGBUILD for $pkg?"
								if [[ $Response == y ]]; then
									$EDITOR "$pkg/PKGBUILD"
									break 1
								else
									msg e "Must download dependencies. Exiting." && exit 1
								fi
							fi
						else
							InstallPacman+=("$dep")
						fi
						IFS=$' '
					done
					unset IFS

					(( completed )) && break
				done
			else
				msg w "$pkg/PKGBUILD not found"
			fi
			
			break
		else
			msg e "could not download $pkg." && return 1
		fi
	fi
}

spin_download() { #$1 = package; $2 = print (optional)
	local package url result

	package="$1"
	url="$PROTO://$AUR/packages/$package/$package.tar.gz"
	create_tmp	|| return 1
	
	[[ -e $Tmp_build/$package ]] && msg e "already downloaded" && return 1
	[[ $2 == print && -e $package ]] && msg e "$package/ exists in this directory" && return 1

	#copy from Custom if available
	if [[ -n $Custom && -e $Custom/$package/PKGBUILD ]]; then
		cp -r "$Custom/$package" ./
		result=$?
	else
		spin_curl p "$package" "$package.tar.gz"
		tar xzf "$package.tar.gz" &>/dev/null
		result=$?
		rm "$package.tar.gz" &>/dev/null
	fi

	if [[ $2 == print ]]; then
		(( $result == 0 )) && \
			msg c "Saved" "$package/" || \
			msg c "Not Saved" "$package/"
	else
		return $result
	fi
}

spin_help() {
	cat <<EOF
Usage: spinach [options] [operation] [packages]

  Options
    --[no]ssl	Use SSL
    --[no]col	Use Color
    --[no]rep	Also use repositories
    --max 10	Set max threads
    --tmp dir	Set temp directory
    --edit vim	Set \$EDITOR

  Common Operations
    -s[q] pkg	Search
    -p pkg	Print info
    -i pkg	Install
    -u		Update all

  Do-it-yourself Operations
    -d pkg	Download
    -dd pkg	Download with depends
    -o		List out-of-date
    -do		Download out-of-date

Try \`man spinach' for more information.
EOF
}

#
# "behind the scenes" functions
#

build_all() {
	local i pkg files

	#build (in reverse)
	for (( i=${#InstallDepends[@]}-1; i >= 0; i-- )); do
		pkg="${InstallDepends[$i]}"
		cd "$pkg"
		
		#build, correct, build, etc.
		build_continue "$pkg"
		
		#install files later
		shopt -s nullglob dotglob
		files=("$Tmp_build/$pkg"/*.pkg.tar.xz)
		shopt -u nullglob dotglob
		
		#install
		(( ${#files[@]} > 0 )) && \
			run_pacman --noconfirm --asdeps -U "${files[@]}"

		#cache
		for pkg in "${files[@]}"; do
			 mv "$pkg" "$Tmp_cache/"
		done

		cd "$Tmp_build"
	done
	
	for (( i=${#InstallExplicit[@]}-1; i >= 0; i-- )); do
		pkg="${InstallExplicit[$i]}"
		cd "$pkg"
		
		#build, correct, build, etc.
		build_continue "$pkg"
		
		#install files later
		shopt -s nullglob dotglob
		CompiledExplicit+=("$Tmp_build/$pkg"/*.pkg.tar.xz)
		shopt -u nullglob dotglob

		cd "$Tmp_build"
	done

	#install
	(( ${#CompiledExplicit[@]} > 0 )) && \
		run_pacman --noconfirm -U "${CompiledExplicit[@]}" || \
		{ (( Fromrepo == 0 )) && msg n "That's weird... nothing to install."; }

	#move to cache
	for pkg in "${CompiledExplicit[@]}"; do 
		mv "$pkg" "$Tmp_cache/"
	done
}

build_continue() {
	local pkg inst
	pkg="$1"

	while true; do
		if makepkg -c; then
			break
		else
			yes_no "Correct files for $pkg?"

			if [[ $Response == y ]]; then
				$EDITOR "PKGBUILD"

				inst="$(grep ^install= "PKGBUILD" | cut -d= -f2 | tr -d "'\"")"
				[[ -e $inst ]] && $EDITOR "$inst"
			else
				msg e "error building $pkg. Exiting."
				exit 1
			fi
		fi
	done
}

spin_curl() {
	local t f s o

	case "$1" in
		p) t="$Pkg"; f="$2"; s="$2"; o="$3";;
		r) t="$Rpc"; f="$2"; s="$3"; o="-";;
		*) return 1;;
	esac

	curl -sfA "$UA" --compressed "$(printf "%s://%s/$t" "$Proto" "$Host" "$f" "$s")" -o "$o"
}

clean_downloaded() {
	local file

	for file in "${Downloaded[@]}"; do
		[[ -e $Tmp_build/$file ]] && rm -rf "$Tmp_build/$file" &>/dev/null
	done
}

msg() {
	local t msg
	msg="$2"

	case "$1" in
		e) t="Error";;
		w) t="Warning";;
		n) t="Notice";;
		v) t="Verbose";;
		c) t="$2"; msg="$3";;
		*) return 1;;
	esac

	if [[ $1 == v ]]; then
		((v)) && printf "${Red}%s${Nc}: %s\n" "$t" "$msg"
	else
		printf "${Red}%s${Nc}: %s\n" "$t" "$msg"
	fi
}

run_pacman() {
	while true; do
		if type sudo &>/dev/null; then
			msg c "Running" "sudo pacman $*"
			sudo pacman "$@"
		else
			msg c "Running" "su root -c pacman $*"
			su root -c pacman "$@"
		fi

		(( $? == 0 )) && break
		
		yes_no "Try again?"
		[[ $Response == n ]] && break
	done
}

preview() {
	local inst pkg
	pkg="$1"

	yes_no "View $pkg?"
	if [[ $Response == y ]]; then
		$EDITOR "PKGBUILD"

		inst="$(grep ^install= "PKGBUILD" | cut -d= -f2 | tr -d "'\"")"
		[[ -e $inst ]] && $EDITOR "$inst"
	fi

	yes_no "Install $pkg?"
	[[ $Response != y ]] && msg e "Not installing. Exiting." && exit 1
}

yes_no() {
	local resp

	while true; do
		printf "${Red}y/n${Nc}: %s " "$1"
		read resp

		if [[ $resp == y || $resp == n ]]; then
			Response="$resp"
			return 0
		fi
	done
}

blank_editor() {
	local i

	if [[ -z $EDITOR ]]; then
		for i in vim emacs vi nano most less more cat; do
			if type $i &>/dev/null; then
				EDITOR="$i"
				msg n "No \$EDITOR, using '$i'"
				break
			fi
		done

		[[ -z $EDITOR ]] && msg e "set \$EDITOR" && return 1
	fi
}

display_color() {
	[[ $Red ]] && cat | sed -r 's/^([^: \t]+[^:]*): +/\'$Red'\1\'$Nc': /g' | \
		xargs -0 echo -en || cat
}

create_tmp() {
	[[ -z $Spintmpdir ]] && Spintmpdir=${TMPDIR:-/tmp}

	Tmp="$Spintmpdir/spinach"
	Tmp_build="$Tmp/build"
	Tmp_cache="$Tmp/cache"
	if ! mkdir -p "$Tmp" "$Tmp_build" "$Tmp_cache" &>/dev/null; then
		msg e "could not create $Tmp"
		return 1
	fi
}

set_color() {
	Red=$(tput setaf 1)
	Green=$(tput setaf 2)
	Yellow=$(tput setaf 3)
	Blue=$(tput setaf 4)
	Nc=$(tput sgr0)
}

unset_color() {
	unset Red Green Yellow Blue Nc
}

blank_arg() {
	[[ -z $1 ]] && msg e "Please specify at least one package." && exit 1
}

chkop() {
	[[ -n $Op ]] && msg e "You can only specify one operation."&& exit 1
}

sudov() {
	while true; do
		sudo -n -v
		sleep $SudovSleep
	done
}

#defaults from config
config=${XDG_CONFIG_HOME:-$HOME/.config}/spinach/config

if [[ -e $config ]]; then
	grep -q '^UseSSL' "$config" && Proto="https"
	grep -q '^UseRepos' "$config" && Rep=1
	grep -q '^UseColor' "$config" && set_color
	grep -q '^Threads=' "$config" && \
		Threads="$(grep -s '^Threads=' "$config" | cut -d= -f2)"
	grep -q '^Temp=' "$config" && \
		Spintmpdir="$(grep -s '^Temp=' "$config" | cut -d= -f2)"
	grep -q '^Editor=' "$config" && \
		EDITOR="$(grep -s '^Editor=' "$config" | cut -d= -f2)"
	grep -q '^Custom=' "$config" && \
		Custom="$(grep -s '^Custom=' "$config" | cut -d= -f2)"
fi

while [[ -n $1 ]]; do
	case "$1" in
		#options
		"--ssl") Proto="https";;
		"--rep") Rep=1;;
		"--col") set_color;;
		"--nossl") Proto="http";;
		"--norep") unset Rep;;
		"--nocol") unset_color;;
		"--max") shift; blank_arg "$1"; Threads="$1";;
		"--tmp") shift; blank_arg "$1"; Spintmpdir="$1";;
		"--edit") shift; blank_arg "$1"; EDITOR="$1";;
		"--custom") shift; blank_arg "$1"; Custom="$1";;
		#common
		"-s") chkop; Op="s";;
		"-sq") chkop; Op="sq";;
		"-i") chkop; Op="i";;
		"-p") chkop; Op="p";;
		"-u") chkop; Op="u";;
		#diy
		"-o") chkop; Op="o";;
		"-d") chkop; Op="d";;
		"-dd") chkop; Op="dd";;
		"-do") chkop; Op="do";;
		#other
		"--version") echo "$UA/$VE"; exit 0;;
		"-h"|"--help") spin_help; exit 0;;
		#packages
		*) pkgargs+=("$1");;
	esac
	shift
done

if [[ $Op ]]; then
	#disable color if piped to another command
	[[ ! -t 1 ]] && unset_color

	#make Custom absolute if "./"
	[[ $Custom == ./ ]] && Custom="$(pwd)"

	case "$Op" in
		u)  spin_update;			exit 0;;
		o)  spin_find_updates;			exit 0;;
		do) spin_download_updates;		exit 0;;
		i)  spin_install "${pkgargs[@]}";	exit 0;;
	esac

	if (( ${#pkgargs[@]} > 0 )); then
		for pkg in "${pkgargs[@]}"; do
			case "$Op" in
				s)  spin_search v 	"$pkg";;
				sq) spin_search q 	"$pkg";;
				p)  spin_info     	"$pkg";;
				d)  spin_download	"$pkg" print;;
				dd) spin_download_all e "$pkg";;
			esac
		done
	else
		blank_arg
	fi
fi
