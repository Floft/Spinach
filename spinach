#!/bin/bash
UA="Spinach"
VE="0.5.0"

#get p url out.tar.gz
#get r info name
#get r search name
#curl $(get rp type arg)
get() {
	local str out rpc1 rpc2
	local print=0;
	local host="aur.archlinux.org"
	local rpc="/rpc.php?type=%s&arg=%s"

	case "$1" in
		p) str="$2%s%s"; out="$3";;
		r) str="$rpc";   out="-"; rpc1="$2"; rpc2="$3";;
		rp) str="$rpc";  out="-"; rpc1="$2"; rpc2="$3"; print=1;;
		*) return 1;
	esac
	
	local url="$(printf "%s://%s$str" "$Proto" "$host" "$rpc1" "$rpc2")"

	((print)) && echo "$url" || curl -sfA "$UA" --compressed "$url" -o "$out"

	return $?
}

#msg e error
#msg n notice
#msg w warning
#msg c prefix message
msg() {
	local txt="$2"
	local prefix=""

	case "$1" in
		e) prefix="Error";;
		n) prefix="Notice";;
		w) prefix="Warning";;
		c) prefix="$2"; txt="$3";;
		*) return 1;;
	esac
	
	printf "${Color}%s${NoColor}: %s\n" "$prefix" "$txt" >&2

	return 0
}

#set_color
set_color() {
	local red=$(tput setaf 1)
	local green=$(tput setaf 2)
	local blue=$(tput setaf 4)
	#local yellow=$(tput setaf 3)
	local nc=$(tput sgr0)

	if (( UseColor )); then
		Color="$red"
		UpdateOld="$blue"
		UpdateNew="$green"
		NoColor="$nc"
	else
		unset Color NoColor UpdateOld UpdateNew
	fi

	return 0
}

#command | color
color() {
	[[ $Color ]] && cat | sed -r 's/^([^: \t]+[^:]*): +/\'$Color'\1\'$NoColor': /g' | \
		xargs -0 echo -en || cat
	
	return 0
}

#ask "really?" || break
ask() {
	local response
	local question="$1"

	while [[ $response != y && $response != n ]]; do
		printf "${Color}y/n${NoColor}: %s " "$question" >&2
		read -r response
	done

	[[ $response == y ]] && return 0
	[[ $response == n ]] && return 1
}

#preview name
preview() {
	local name="$1"
	local question=${2:-View}

	if ask "${question} ${name}?"; then
		"$EDITOR" "PKGBUILD"

		install_file="$(grep ^install= "PKGBUILD" | cut -d= -f2 | tr -d "'\"")"
		[[ -e $install_file ]] && "$EDITOR" "$install_file"
	fi

	ask "Install $name?"
	return $?
}

#run_pacman -S something
run_pacman() {
	while true; do
		if type sudo &>/dev/null; then
			msg c "Running" "sudo pacman $*"
			sudo pacman "$@"
		else
			msg c "Running" "su root -c pacman $*"
			su root -c pacman "$@"
		fi

		(( $? == 0 )) && return 0
		ask "Try again?" || return 1
	done
}

#search v name
#search q name
search() {
	local verbosity="$1"
	local query="$2"
		
	if (( UseAUR3 )); then
		(( UseRepos )) && pacman -Ssq "$query"

		exec 3<>/dev/tcp/aur3.org/1819
		echo "nd $query" >&3
		cat <&3
		echo

		return 0
	fi

	if [[ $verbosity == q ]]; then
		(( UseRepos )) && pacman -Ssq "$query"
		get r search "$query" | jshon -QC -e results -a -e Name -u
	else
		(( UseRepos)) && pacman -Ss "$query" | \
		sed -r 's/^([^/\s]+\/[^ ]+) [^\n]+$/\1/g' | \
		sed -rn '1h;1!H;${;g;s/\n\s+/: /g;p;}' | color
		
		get r search "$query" | \
			jshon -QC -e results -a -e Name -u -p -e OutOfDate -u -p -e Description -u  | \
			paste -s -d " :\n" | sed -r '
			s/^([^:]*) 0:/\1: /g
			s/^([^:]*) 1:/\1 *: /g
			' | sort | color
	fi

	return 0
}

#info query
info() {
	local info gotinfo
	local query="$1"
	
	if (( UseRepos )); then
		info="$(pacman -Si "$query" 2>/dev/null)"
		gotinfo=$?

		[[ $info ]] && color <<< "$info"
	fi

	if ! (( UseRepos )) || (( gotinfo )); then
		(( UseAUR3 )) && \
			curl -sfA "$UA" "http://aur3.org/rpc/$query" | jshon || \
			get r info "$query" | jshon -QC -e results | \
				tail -n +2 | head -n -1 | sed -r '
				s/^ "//g
				s/": "/: /g
				s/",?$//g
				s/^URLPath: /URLPath: https:\/\/aur.archlinux.org/g' | color
	fi
	
	return 0
}

#get_pkg name [ignore]
get_pkg() {
	local url
	local result=0
	local name="$1"
	local ignore=$2
	(( UseAUR3 )) && \
		url="$(curl -sfA "$UA" "http://aur3.org/rpc/$name" | jshon -e targz -u)" || \
		url="$(get r info "$name" | jshon -QC -e results -e URLPath -u)"

	[[ -z $ignore ]] && ignore=0

	if [[ -e $name ]]; then
		if (( ignore )); then
			return 0
		else
			msg e "$name/ exists"
			return 1
		fi
	fi

	if [[ -n $Custom && -e $Custom/$name/PKGBUILD ]]; then
		msg n "Using PKGBUILD from $Custom"
		cp -r "$Custom/$name" ./
		result=$?
	else
		(( UseAUR3 )) && \
			curl -sfA "$UA" "$url" -o "$name.tar.gz" || \
			get p "$url" "$name.tar.gz"
		tar xzf "$name.tar.gz" &>/dev/null
		result=$?
		rm "$name.tar.gz" &>/dev/null
	fi

	(( $result == 0 )) && \
		msg c "Saved" "$name/" || \
		msg c "Not Saved" "$name/"
	
	return $result
}

#get_all name
get_all() {
	local dep 
	local result=0
	local name="$1"
	local explicit=$2

	[[ -z $explicit ]] && explicit=1

	if (( explicit )); then
		[[ -e $name ]]  && { msg n "already downloaded $name/"; return 1; }
		get_pkg "$name" || { msg e "could not download $name";  return 1; }
	else
		get_pkg "$name" 1 || { msg e "could not download $name";  return 1; }
	fi

	Downloaded+=("$name")
	(( explicit )) && \
		InstallExplicit+=("$name") || \
		InstallDepends+=("$name")
	
	[[ -e $name/PKGBUILD ]] || { msg e "$name/PKGBUILD does not exist"; return 1; }

	grep sudo "$name/PKGBUILD" &>/dev/null && \
		msg w "The characters 'sudo' are in the PKGBUILD."
	grep sudo "$name/"*.install &>/dev/null && \
		msg w "The characters 'sudo' are in the install file."

	local finished=0;

	while ! (( finished )) ; do
		finished=1

		#TODO is this safe?
		source <(tr '\n' ' ' < "$name/PKGBUILD" | grep -Eo ' (make)?depends=\([^)]*\)' | \
			sed -r "s/(['\"])([^><='\"]*)[><=]+[^'\"]*\1/\1\2\1/g")
		
		local deps="$(pacman -T ${depends[*]} ${makedepends[*]} | tr '\n' ' ')"

		local provide=""

		[[ -n $deps ]] && provide="$(pacman -Si $(pacman -Ssq "^($(tr ' ' '|' <<< "$deps"))$" || echo -h) | \
			grep -E "^(Name|Provides)" | sed '
			s/^[^:]*: //g
			s/=[^ ]*//g' | tr ' ' '\n')"

		for dep in $deps; do
			grep -q "^$dep$" <<< "$provide" && InstallPacman+=("$dep") && continue
			
			if ! get_all "$dep" 0; then
				finished=0

				if ask "Modify PKGBUILD for $pkg?"; then
					"$EDITOR" "$pkg/PKGBUILD"
					break 1
				else
					msg e "Must download dependencies."
					return 1
				fi
			fi
		done
	done
}

#notfound
notfound() {
	local thread_list=()
	local packages="$(pacman -Qmq)"

	trap "for t in \"\${thread_list[@]}\"; do kill \$t &>/dev/null; done; echo; exit 1" 0 2 15

	for pkg in $packages; do
		if (( UseAUR3 )); then
			curl -sfA "$UA" "http://aur3.org/rpc/$pkg" &>/dev/null || msg c "Not found" "$pkg" &
			thread_list+=("$!")
		else
			get r info "$pkg" | grep "No result" &>/dev/null && msg c "Not found" "$pkg" &
			thread_list+=("$!")
		fi

		thread_wait $Threads
	done
		
	thread_wait

	trap - 0 2 15
}

#thread_wait $Threads
thread_wait() {
	local threads="$1"
	[[ -z threads ]] && threads=0

	while (( $(jobs|wc -l) > threads )); do
		sleep 0.05
		jobs &>/dev/null
	done &>/dev/null
}

#while read -r pkg; do echo $pkg; done < <(updates)
updates() {
	local pkg file info
	local count=0
	local threads=()
	local kill_list=()
	local tmp="$(mktemp -u)$$"
	(( UseAUR3 )) && \
		info="http://aur3.org/rpc/" || \
		info="$(get rp info "")"

	trap "kill \"\${kill_list[@]}\" &>/dev/null; rm \"$tmp\"_* &>/dev/null; exit 1" 0 2 15

	#get urls
	local packages="$(pacman -Qmq)"
	for pkg in $packages; do
		[[ -z ${threads[$count]} ]] && \
			threads[$count]="$pkg" || \
			threads[$count]+=",$pkg"
		(( count == Threads-1 )) && count=0 || (( ++count ))
	done

	#create threads
	count=0
	for pkg in "${threads[@]}"; do
		curl -sfA "$UA" --compressed "$info{$pkg}" -o "${tmp}_${count}_#1" &>/dev/null &
		kill_list+=("$!")
		(( ++count ))
	done

	#wait
	thread_wait

	#parse AUR versions
	local aur=()
	while read -r file; do
		(( UseAUR3 )) && \
			aur+=("$(jshon -QC -e name -u -p -e pkgver -u -p -e pkgrel -u < "$file" | paste -sd '\t-\n')") || \
			aur+=("$(jshon -QC -e results -e Name -u -p -e Version -u < "$file" | paste -sd '\t\n')")
		rm "$file"
	done < <(ls "$tmp"_* 2>/dev/null)
	
	trap - 0 2 15

	#parse local versions
	local pacman="$(pacman -Qi $packages | grep -E "^(Name|Version)" | sed 's/^.[^:]*: //g')"

	#compare
	for pkg in "${aur[@]}"; do
		local name="$(cut -f1 <<< "$pkg")"
		local aur="$(cut -f2 <<< "$pkg")"				#AUR version
		local loc="$(grep -A 1 "^$name$" <<< "$pacman" | tail -n 1)"	#local version

		if [[ $aur != $loc && -n $loc ]] && (( $(vercmp "$aur" "$loc") > 0 )); then
			echo "$name"
			printf "${Color}%s${NoColor} (${UpdateOld}%s${NoColor} => ${UpdateNew}%s${NoColor})\n" \
				"$name" "$loc" "$aur" >&2
		fi
	done
}

#install_pkg "${packages[@]}"
install_pkg() {
	editor || return 1
	mk_tmp || return 1

	cd "$Build"

	local pkg
	local installAur=()
	local installRepo=()
	Downloaded=()
	InstallPacman=()
	InstallDepends=()
	InstallExplicit=()
	
	trap "touch \"$Tmp/$KillSudov\"; clean; wait; rm \"$Tmp/$KillSudov\"; exit 1" 0
	trap "touch \"$Tmp/$KillSudov\"; clean; wait; rm \"$Tmp/$KillSudov\"; echo; exit 1" 2 15

	for pkg; do
		if (( UseRepos )) && { pacman -Si "$pkg" &>/dev/null || \
			(( $(pacman -Sgq "$pkg" 2>/dev/null | wc -l) )); }; then
			installRepo+=("$pkg")
		else
			if ! (( Needed )) || ! pacman -Qi "$pkg" &>/dev/null; then
				installAur+=("$pkg")
			fi
		fi
	done

	if (( ${#installRepo[@]} > 0 )); then
		(( Needed )) && run_pacman --needed -S "${installRepo[@]}" || \
				run_pacman          -S "${installRepo[@]}"
	fi

	build "${installAur[@]}" || return 1
	
	touch "$Tmp/$KillSudov"
	clean
	wait
	rm "$Tmp/$KillSudov"
	trap - 0 2 15
}

#install_updates
install_updates() {
	editor || return 1
	mk_tmp || return 1

	cd "$Build"

	local update pkg 
	local packages=()
	local upgrade_pkgs=()
	Downloaded=()
	InstallPacman=()
	InstallDepends=()
	InstallExplicit=()

	while read -r update; do
		packages+=("$update")
	done < <(updates)

	[[ -e $Tmp/update.lock ]] && msg e "update lock exists in $Tmp/" && return 1
	touch "$Tmp/update.lock"

	trap "touch \"$Tmp/$KillSudov\"; clean; rm \"$Tmp/update.lock\" &>/dev/null; wait; rm \"$Tmp/$KillSudov\"; exit 1" 0
	trap "touch \"$Tmp/$KillSudov\"; clean; rm \"$Tmp/update.lock\" &>/dev/null; wait; rm \"$Tmp/$KillSudov\"; echo; exit 1" 2 15

	for pkg in "${packages[@]}"; do
		ask "Update $pkg?" && upgrade_pkgs+=("$pkg")
	done

	build "${upgrade_pkgs[@]}" || return 1

	check_running

	rm "$Tmp/update.lock"
	touch "$Tmp/$KillSudov"
	clean
	wait
	rm "$Tmp/$KillSudov"
	trap - 0 2 15
}

#build package(s) || return 1
build() {
	local pkg i PKGEXT

	for pkg; do
		get_all "$pkg"
	done

	(( $# == 0 )) 	  		  && return 0 #no packages to install
	(( ${#InstallExplicit[@]} == 0 )) && return 1 #couldn't find packages

	for pkg in "${InstallExplicit[@]}" "${InstallDepends[@]}"; do
		cd "$pkg"
		preview "$pkg" || { msg e "not building package. Exiting."; return 1; }
		cd "$Build"
	done

	(( ${#InstallPacman[@]} > 0 )) && \
		run_pacman --needed --asdeps -S "${InstallPacman[@]}"

	if (( UseBatch )) && type sudo &>/dev/null; then
		msg c "Running" "sudo -v"
		if sudo -v; then
			sudov &
		else
			msg n "Falling back to non-batch mode"
		fi
	fi

	source <(grep ^PKGEXT= /etc/makepkg.conf)
	[[ -z $PKGEXT ]] && PKGEXT='.pkg.tar.xz'

	for (( i=${#InstallDepends[@]}-1; i >= 0; --i )); do
		if ! mk_pkg "${InstallDepends[$i]}" "$PKGEXT" 1; then
			msg e "must build depends. Exiting."
			return 1
		fi
	done

	for pkg in "${InstallExplicit[@]}"; do
		mk_pkg "$pkg" "$PKGEXT" 0
	done
}

#mk_pkg dir PKGEXT depends
mk_pkg() {
	local i PKGEXT asdeps files
	local pkg="$1"
	local makepkg_pkgext="$2"
	local is_depend=$3

	(( is_depend )) && asdeps="--asdeps"

	cd "$pkg"

	while true; do
		if makepkg; then
			[[ -d pkg/usr/bin ]] && for i in pkg/usr/bin/*; do
				[[ -f $i ]] && UserBin+=("${i//*\//}")
			done

			rm -rf src/ pkg/
			break
		else
			if ! preview "$pkg" "Correct files for"; then
				msg e "could not build $pkg"
				cd "$Build"
				return 1
			fi
		fi
	done

	source <(grep ^PKGEXT= PKGBUILD)
	[[ -z $PKGEXT ]] && PKGEXT="$makepkg_pkgext"

	shopt -s nullglob dotglob
	files=("$Build/$pkg"/*$PKGEXT)
	shopt -u nullglob dotglob

	if (( ${#files[@]} > 0 )); then
		if (( UseBatch )); then
			run_pacman --noconfirm $asdeps -U "${files[@]}"
		else
			run_pacman $asdeps -U "${files[@]}"
		fi
	fi

	for i in "${files[@]}"; do
		mv "$i" "$Cache/"
	done

	cd "$Build"
}

#find_updates
find_updates() {
	updates >/dev/null
}

#get_updates
get_updates() {
	local update

	while read -r update; do
		get_pkg "$update"
	done < <(updates)
}

#sudov &
sudov() {
	while [[ ! -e $Tmp/$KillSudov ]]; do
		sudo -n -v
		sleep $Sleep
	done
}

#clean
clean() {
	local file
	
	for file in "${Downloaded[@]}"; do
		[[ -e $Build/$file ]] && rm -rf "$Build/$file" &>/dev/null
	done
}

#check_running
check_running() {
	local i

	type ps &>/dev/null || return 0

	for i in "${UsrBin[@]}"; do
			if [[ $i != spinach ]] && ps -eo comm 2>/dev/null | grep "$i" &>/dev/null; then
				msg n "/usr/bin/$i appears to be running and was updated."
			fi
	done
}

#editor || return 1
editor() {
	local i

	[[ -n $EDITOR ]] && return 0

	for i in vim emacs vi nano most less more cat; do
		if type "$i" &>/dev/null; then
			EDITOR="$i"
			msg n "No \$EDITOR, using '$i'"
			break
		fi
	done

	[[ -z $EDITOR ]] && msg e "set \$EDITOR" && return 1

	return 0
}

#mk_tmp || return 1
mk_tmp() {
	[[ -z $Temp ]] && Temp=${TMPDIR:-/tmp}

	Tmp="$Temp/spinach"
	Build="$Tmp/build"
	Cache="$Tmp/cache"

	if ! mkdir -p "$Tmp" "$Build" "$Cache" &>/dev/null; then
		msg e "could not create $Tmp"
		return 1
	fi

	return 0
}

blank() {
	[[ -z $1 ]] && msg e "Please specify at least one package." && exit 1
}

chkop() {
	[[ -n $Op ]] && msg e "You can only specify one operation." && exit 1
}

usage() {
	cat <<EOF
Usage: spinach [options] [operation] [packages]

  Options
    --[no]ssl	Use SSL
    --[no]col	Use Color
    --[no]rep	Use repos
    --[no]bat	Use batch mode
    --max 10	Set max threads
    --edit vim	Set \$EDITOR
    --aur3	Use aur3.org mirror
    --custom d	Local AUR packages
    --needed	Only install new packages

  Common Operations
    -s[q] pkg	Search
    -p    pkg	Print info
    -i    pkg	Install
    -u		Update

  Do-it-yourself Operations
    -d    pkg	Download
    -dd   pkg	Download with depends
    -o		List updates
    -do		Download updates
     --404	List packages not in AUR

Try \`man spinach' for more information.
EOF

	return 0
}

unset Op Temp Custom

Threads=10
Sleep=2
UsrBin=()
Pkgargs=()
KillSudov="killsudov$$.lock"

Needed=0
UseSSL=0
UseAUR3=0
UseRepos=1
UseColor=1
UseBatch=1

#defaults from config
config=${XDG_CONFIG_HOME:-$HOME/.config}/spinach/config

[[ -e $config ]] && source "$config"

while [[ -n $1 ]]; do
	case "$1" in
		#options
		"--ssl")    UseSSL=1;;
		"--nossl")  UseSSL=0;;
		"--col")    UseColor=1;;
		"--nocol")  UseColor=0;;
		"--rep")    UseRepos=1;;
		"--norep")  UseRepos=0;;
		"--bat")    UseBatch=1;;
		"--nobat")  UseBatch=0;;
		"--aur3")   UseAUR3=1;;
		"--tmp")    shift; blank "$1"; Temp="$1";;
		"--max")    shift; blank "$1"; Threads="$1";;
		"--edit")   shift; blank "$1"; EDITOR="$1";;
		"--custom") shift; blank "$1"; Custom="$1";;
		"--nocustom") unset Custom;;
		"--needed") Needed=1;;
		#common
		"-s")  chkop; Op="s";;
		"-sq") chkop; Op="sq";;
		"-i")  chkop; Op="i";;
		"-p")  chkop; Op="p";;
		"-u")  chkop; Op="u";;
		#diy
		"-o")  chkop; Op="o";;
		"-d")  chkop; Op="d";;
		"-dd") chkop; Op="dd";;
		"-do") chkop; Op="do";;
		#other
		"--404") chkop; Op="404";;
		"--version") echo "$UA/$VE"; exit 0;;
		"-h"|"--help") usage; exit 0;;
		*) Pkgargs+=("$1");;
	esac
	shift
done

if [[ $Op ]]; then
	#disable color if piped to another command
	[[ ! -t 1 ]] && UseColor=0
	set_color
	
	(( UseSSL )) && Proto="https" || Proto="http"

	#need absolute
	[[ $Custom == ./ ]] && Custom="$(pwd)"

	case "$Op" in
		u)      install_updates;		exit 0;;
		o)      find_updates;			exit 0;;
		do)     get_updates; 			exit 0;;
		i)      install_pkg "${Pkgargs[@]}";	exit 0;;
		404)    notfound;			exit 0;;
	esac

	if (( ${#Pkgargs[@]} > 0 )); then
		for pkg in "${Pkgargs[@]}"; do
			case "$Op" in
				s)  search v "$pkg";;
				sq) search q "$pkg";;
				p)  info     "$pkg";;
				d)  get_pkg  "$pkg";;
				dd) get_all  "$pkg";;
			esac
		done
	else
		blank
	fi
fi
